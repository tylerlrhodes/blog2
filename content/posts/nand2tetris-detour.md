---
title: "Nand2Tetris"
date: 2018-07-03T10:23:48-04:00
draft: false
series: personal
tags: [
      "nand2tetris"
]
---

Well it didn't take long, but I've already been distracted a bit from
my SICP journey.  I bought a new book, "The Elements of Computing
Systems" and found the Coursera course which goes along with it.  I
even decided to pay the 50 dollars for part 1 of Nand2Tetris on
Coursera, so that I have access to the graded portion of the course.

The course description says that it takes about 5-10 hours a week to
work through the material, and having almost completed the first weeks
work (there are 6 weeks in the first course which cover the first half
of the book) that seems about right.  This should leave me a little
time to also work through SICP in parallel.  I find that the busier I
am the more that I get done.

The course has me pretty excited.  Part 1 of the course which I'm
doing now entails building a virtual computer using a Hardware
Description Language (HDL) for the course and a hardware simulator.
This is done starting with nothing but a NAND gate, and from there
building all of the other chips and components of the computer.  I
believe the first part ends with a basic assembly language for the
computer which can be used to program it.

Part 2 of the course moves away from the hardware a little bit and
goes into building a virtual machine, compiler and basic operating
system for the computer built in the first part.

It's exciting to think that in the span of three months or so, using
the hardware simulator the course comes with, it will be possible to
build an entire computing environment complete with a basic OS.

The course also seems to make you think a lot too.  It gives you the
basic building blocks and leaves you to figure out how to do it.  This
means that in the space of three months, the course will be covering a
lot of different topics in a fairly shallow manner.  I'm particularly
interested in how the compiler is taught -- there are two chapters on
building this and I believe it compiles the Jack programming language
to bytecode to run on the VM which is built.

I'm also excited about getting started on Coursera again.  The last
course on Algorithms that I took was great to work with.  The format
works well, the lectures are typically very high quality, and the site
is pretty easy to work with.

I'm interested to see how I follow through with doing this before
paying additional money for some other Coursera courses.  They have a
new specialization on Discrete Math that I'd like to do, which is 70
dollars a month.  That is a series of five or six courses I believe,
which would probably take six months or so to complete.

Of course it seems that nearly all of the work done in this course
won't be directly applicable to anything I do at work.  The one
exception to this is applying the principle of abstraction, which is
something of course that any programmer is familiar with.  While this
course won't be teaching object oriented design in C# or JavaScript,
being exposed to new ways of building things from component parts as
this course does, can lead to new ways of thinking about familiar
subjects.

Working as a software engineer for 3 or 4 years now, after working as
a systems/network integrator, it's interesting to take the time to
learn more fundamental concepts about computing.  It's amazing how so
many different things are put together to build the systems that we
see today, from the low level hardware all the way up to the software
interfaces that we see.  It's also amazing how far you can get
professionally in IT without understanding some of these fundamental
concepts.  I've had a vague understanding of how computers work at the
level this course goes into, but I'd never be able to describe it as
this course does.

My experience professionally has let me see the broad nature of
different roles that are possible in the technology industry.  My
first few jobs invloved working for integration/consulting firms,
where I focused on the core IT systems with some applications level
support as well.  This gave me the chance to learn and appreciate how
the core network and systems infrastructure supports the applications
that users and businesses depend upon.  I also learned how to build
and operate Windows based networks in great detail, down to the
routing and switching level.

My next few jobs moved me into software engineering roles.  These
roles allowed me to work on sophisticated software in the medical
industry.  One of the interesting differences outside of working with
code as opposed to designing and implementing networks, is that
working on applications software requires you to develop sophisticated
domain knowledge with regards to the field you're working in.  To me,
this is one of the challenges of developing software as opposed to
operating networks.  While both require you to have knowledge of the
business domain to some extent, when you work on one piece of
software to develop it, you have to understand programming in addition
to the domain requirements of the software you're implementing.

Having taken the time in the last few years to learn more about some
of the fundamental concepts, partly out of interest and partly to
further my career, and having worked as both a systems engineer and
software engineer, it's clear how important the abstractions are.

As a software engineer you're unlikely to implement nearly any
of the algorithms and data structures you would learn manually now.
Granted, there are exceptions to this, but I would think that a large
swath of working software engineers aren't involved with implementing
their own heaps and stacks on a day to day basis, as the frameworks we
develop with provide them (you do have to know what they are and the
performance characteristics).  

Either way, it's nice to work on a course that is fun and
informative.  I've plugged in the parts of a computer and installed an
operating system on it many times.  I've never built one from logic
gates before and written an OS for it, so this should be fun.


